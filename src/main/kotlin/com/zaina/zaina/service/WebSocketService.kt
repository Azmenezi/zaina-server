package com.zaina.zaina.service

import com.zaina.zaina.dto.*
import com.zaina.zaina.repository.ProfileRepository
import com.zaina.zaina.security.UserPrincipal
import org.slf4j.LoggerFactory
import org.springframework.messaging.simp.SimpMessagingTemplate
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import java.util.concurrent.ConcurrentHashMap

@Service
class WebSocketService(
    private val messagingTemplate: SimpMessagingTemplate,
    private val profileRepository: ProfileRepository
) {
    
    private val logger = LoggerFactory.getLogger(WebSocketService::class.java)
    private val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
    
    // Track online users
    private val onlineUsers = ConcurrentHashMap<UUID, LocalDateTime>()
    
    fun sendMessageToUser(messageResponse: MessageResponse) {
        val timestamp = LocalDateTime.now().format(dateFormatter)
        
        try {
            // Get sender's name for display
            val senderProfile = profileRepository.findByUserId(messageResponse.senderId)
            val senderName = senderProfile?.name
            
            val chatMessage = ChatMessage(
                id = messageResponse.id,
                senderId = messageResponse.senderId,
                receiverId = messageResponse.receiverId,
                content = messageResponse.content,
                sentAt = messageResponse.sentAt,
                senderName = senderName
            )
            
            val webSocketMessage = WebSocketMessage(
                type = MessageType.CHAT_MESSAGE,
                data = chatMessage
            )
            
            logger.info("""
                
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘ ğŸ’¬ WEBSOCKET CHAT MESSAGE BROADCAST - $timestamp
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ Message ID: ${messageResponse.id}
                â•‘ From: ${messageResponse.senderId} (${senderName ?: "Unknown"})
                â•‘ To: ${messageResponse.receiverId}
                â•‘ Content Length: ${messageResponse.content.length} characters
                â•‘ Content Preview: ${messageResponse.content.take(50)}${if (messageResponse.content.length > 50) "..." else ""}
                â•‘ Sent At: ${messageResponse.sentAt}
                â•‘ Destination: /user/${messageResponse.receiverId}/queue/messages
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
            
            // Send to specific user
            messagingTemplate.convertAndSendToUser(
                messageResponse.receiverId.toString(),
                "/queue/messages",
                webSocketMessage
            )
            
            // Also send to sender for confirmation
            messagingTemplate.convertAndSendToUser(
                messageResponse.senderId.toString(),
                "/queue/messages",
                webSocketMessage
            )
            
            logger.info("âœ… Message successfully broadcast to both sender and receiver via WebSocket")
            
        } catch (e: Exception) {
            logger.error("""
                
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘ âŒ WEBSOCKET MESSAGE BROADCAST ERROR - $timestamp
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ Message ID: ${messageResponse.id}
                â•‘ From: ${messageResponse.senderId}
                â•‘ To: ${messageResponse.receiverId}
                â•‘ Error: ${e.message}
                â•‘ Stack Trace: ${e.stackTraceToString().take(300)}
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
        }
    }
    
    fun sendTypingIndicator(typingIndicator: TypingIndicator) {
        val timestamp = LocalDateTime.now().format(dateFormatter)
        
        try {
            val webSocketMessage = WebSocketMessage(
                type = MessageType.TYPING_INDICATOR,
                data = typingIndicator
            )
            
            logger.info("""
                
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘ âŒ¨ï¸ WEBSOCKET TYPING INDICATOR - $timestamp
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ From: ${typingIndicator.senderId} (${typingIndicator.senderName ?: "Unknown"})
                â•‘ To: ${typingIndicator.receiverId}
                â•‘ Typing: ${typingIndicator.typing}
                â•‘ Destination: /user/${typingIndicator.receiverId}/queue/typing
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
            
            messagingTemplate.convertAndSendToUser(
                typingIndicator.receiverId.toString(),
                "/queue/typing",
                webSocketMessage
            )
            
        } catch (e: Exception) {
            logger.error("âŒ Error sending typing indicator via WebSocket: ${e.message}")
        }
    }
    
    fun sendReadReceipt(messageResponse: MessageResponse, readBy: UUID) {
        val timestamp = LocalDateTime.now().format(dateFormatter)
        
        try {
            val readReceipt = MessageReadReceipt(
                messageId = messageResponse.id,
                readBy = readBy,
                readAt = LocalDateTime.now()
            )
            
            val webSocketMessage = WebSocketMessage(
                type = MessageType.MESSAGE_READ_RECEIPT,
                data = readReceipt
            )
            
            logger.info("""
                
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘ âœ“ WEBSOCKET READ RECEIPT - $timestamp
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ Message ID: ${messageResponse.id}
                â•‘ Read By: $readBy
                â•‘ Original Sender: ${messageResponse.senderId}
                â•‘ Read At: ${readReceipt.readAt}
                â•‘ Destination: /user/${messageResponse.senderId}/queue/read-receipts
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
            
            messagingTemplate.convertAndSendToUser(
                messageResponse.senderId.toString(),
                "/queue/read-receipts",
                webSocketMessage
            )
            
        } catch (e: Exception) {
            logger.error("âŒ Error sending read receipt via WebSocket: ${e.message}")
        }
    }
    
    fun updateUserStatus(userId: UUID, online: Boolean) {
        val timestamp = LocalDateTime.now().format(dateFormatter)
        
        try {
            val now = LocalDateTime.now()
            val previousStatus = onlineUsers.containsKey(userId)
            
            if (online) {
                onlineUsers[userId] = now
            } else {
                onlineUsers.remove(userId)
            }
            
            val userStatus = UserStatus(
                userId = userId,
                online = online,
                lastSeen = if (online) null else now
            )
            
            val webSocketMessage = WebSocketMessage(
                type = MessageType.USER_STATUS,
                data = userStatus
            )
            
            logger.info("""
                
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘ ğŸ‘¤ WEBSOCKET USER STATUS UPDATE - $timestamp
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ User ID: $userId
                â•‘ Status Change: ${if (previousStatus) "Online" else "Offline"} â†’ ${if (online) "Online" else "Offline"}
                â•‘ Last Seen: ${if (online) "Currently active" else now}
                â•‘ Total Online Users: ${onlineUsers.size}
                â•‘ Destination: /topic/user-status (broadcast)
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
            
            // Broadcast status to all users (you might want to limit this to connected users)
            messagingTemplate.convertAndSend("/topic/user-status", webSocketMessage)
            
        } catch (e: Exception) {
            logger.error("âŒ Error updating user status via WebSocket: ${e.message}")
        }
    }
    
    fun sendConnectionNotification(connectionResponse: ConnectionResponse) {
        val timestamp = LocalDateTime.now().format(dateFormatter)
        
        try {
            val webSocketMessage = WebSocketMessage(
                type = MessageType.CONNECTION_REQUEST,
                data = connectionResponse
            )
            
            logger.info("""
                
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘ ğŸ¤ WEBSOCKET CONNECTION NOTIFICATION - $timestamp
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ Connection ID: ${connectionResponse.id}
                â•‘ Type: ${connectionResponse.type}
                â•‘ Status: ${connectionResponse.status}
                â•‘ From: ${connectionResponse.requesterId} (${connectionResponse.requesterName ?: "Unknown"})
                â•‘ To: ${connectionResponse.targetId} (${connectionResponse.targetName ?: "Unknown"})
                â•‘ Requested At: ${connectionResponse.requestedAt}
                â•‘ Destination: /user/${connectionResponse.targetId}/queue/connections
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
            
            // Send to target user
            messagingTemplate.convertAndSendToUser(
                connectionResponse.targetId.toString(),
                "/queue/connections",
                webSocketMessage
            )
            
            // If accepted, also notify requester
            if (connectionResponse.status.name == "ACCEPTED") {
                val acceptedMessage = WebSocketMessage(
                    type = MessageType.CONNECTION_ACCEPTED,
                    data = connectionResponse
                )
                
                logger.info("""
                    
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘ âœ… WEBSOCKET CONNECTION ACCEPTED NOTIFICATION - $timestamp
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ Connection ID: ${connectionResponse.id}
                    â•‘ Notifying Requester: ${connectionResponse.requesterId}
                    â•‘ Destination: /user/${connectionResponse.requesterId}/queue/connections
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """.trimIndent())
                
                messagingTemplate.convertAndSendToUser(
                    connectionResponse.requesterId.toString(),
                    "/queue/connections",
                    acceptedMessage
                )
            }
            
        } catch (e: Exception) {
            logger.error("âŒ Error sending connection notification via WebSocket: ${e.message}")
        }
    }
    
    fun getOnlineUsers(): Map<UUID, LocalDateTime> {
        val timestamp = LocalDateTime.now().format(dateFormatter)
        logger.debug("ğŸ“Š Online users requested at $timestamp - Total: ${onlineUsers.size}")
        return onlineUsers.toMap()
    }
    
    fun isUserOnline(userId: UUID): Boolean {
        val isOnline = onlineUsers.containsKey(userId)
        logger.debug("ğŸ‘¤ User status check for $userId: ${if (isOnline) "Online" else "Offline"}")
        return isOnline
    }
    
    fun getUserLastSeen(userId: UUID): LocalDateTime? {
        val lastSeen = onlineUsers[userId]
        logger.debug("ğŸ• Last seen for $userId: ${lastSeen ?: "Never or offline"}")
        return lastSeen
    }
} 